# Tarea-exploit
en esta tarea se modificara y explicara un exploit ya existente con fines educativos

el exploit que he escogido para esta tarea es el CVE-2022-0847


El CVE-2022-0847 es una vulnerabilidad de escalada de privilegios locales en el kernel de Linux que podría permitir a un usuario no privilegiado modificar o sobrescribir archivos de solo lectura como /etc/passwd y obtener una shell elevada. Esta vulnerabilidad se encuentra en el kernel de Linux (desde la versión 5.8) y permite que los actores de amenazas sobrescriban datos arbitrarios en cualquier archivo de lectura en línea. 
Es fácil de explotar y crítico para una vulnerabilidad local del kernel esto debido a que es explotable entodas las distribuciondes de linux que tengan este kernel.

el exploite en el cual me base pertenece al usuario de github Arinerron el cual explota esta vulerabilidad permiiendo escalar privilegios en un sistema linux.

aqui esta el link a ese repositorio

https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/blob/main/exploit.c

en que consiste este exploit?
Se incluyen las bibliotecas necesarias y se definen algunas constantes y variables.

La función prepare_pipe crea una tubería y llena la tubería con datos para establecer una capacidad de fusión en los bloques de datos.

En la función principal (main), se realiza lo siguiente:

1. Se solicita al usuario que ingrese la nueva contraseña para el usuario "root".

2. Se realiza una copia de respaldo del archivo "/etc/passwd" al archivo "/tmp/passwd.bak".

3. Se comprueba si se pudieron abrir los archivos correctamente. Si alguno de ellos falla, se muestra un mensaje de error y se sale del programa.

4. Se copia el contenido del archivo "/etc/passwd" al archivo de respaldo "/tmp/passwd.bak" caracter por caracter.

5. Se cierran los archivos abiertos.

Se establece un desplazamiento (offset) en el valor 4 y se obtiene la nueva contraseña ingresada por el usuario.


El offset es una variable que indica la posición dentro de un archivo donde se realizará una operación de escritura o lectura. En el código, el offset se utiliza para determinar la ubicación dentro del archivo "/etc/passwd" donde se escribirá la nueva contraseña del usuario "root".

En la versión original del código, el valor del offset se establece en 4, lo que significa que la escritura de la nueva contraseña comenzará después de los primeros 4 bytes en el archivo. Esto se debe a que se desea sobrescribir la contraseña existente para el usuario "root" en el archivo "/etc/passwd" con la nueva contraseña ingresada.

Es importante tener en cuenta que el offset se utiliza en combinación con el tamaño de página (PAGE_SIZE) para asegurarse de que la escritura no cruce los límites de página. Un límite de página es una restricción impuesta por el sistema operativo que especifica que la escritura o lectura de datos debe ocurrir en múltiplos enteros del tamaño de página.

En el código, se realiza una comprobación para asegurarse de que el offset no esté alineado con el tamaño de página (offset % PAGE_SIZE == 0). Si el offset está alineado con el tamaño de página, se muestra un mensaje de error y el programa termina. Esto se debe a que escribir en un límite de página podría tener consecuencias inesperadas y no deseables.


Se comprueba si el desplazamiento está alineado con el tamaño de página (PAGE_SIZE). Si no lo está, se muestra un mensaje de error y se sale del programa.

Se calcula el próximo límite de página (next_page) y se verifica si el desplazamiento más el tamaño de los datos supera el límite de página. Si es así, se muestra un mensaje de error y se sale del programa.

Se inicializa una variable data con la contraseña ingresada por el usuario y se muestra un mensaje con la contraseña establecida para el usuario "root".

Se comprueba si el desplazamiento es válido y si el tamaño de los datos es válido para realizar la escritura en el archivo "/etc/passwd". Si alguna de estas comprobaciones falla, se muestra un mensaje de error y se sale del programa.

Se llama a la función prepare_pipe para crear una tubería especial con capacidades de fusión en los bloques de datos.

Se utiliza la función splice para transferir un byte del archivo antes del desplazamiento especificado a la tubería. Esto agrega una referencia a la caché de páginas, pero las capacidades de fusión de los bloques de datos no se inicializan.

Se escribe la contraseña ingresada por el usuario en la tubería. Debido a las capacidades de fusión establecidas en los bloques de datos de la tubería, esta escritura no crea nuevos bloques de datos, sino que se fusiona en la caché de páginas.

Finalmente, el programa muestra un mensaje para indicar que la función execv (que no se muestra en el código proporcionado) se ha llamado para ejecutar un comando específico. Si la llamada a execv tiene éxito, el programa no llegará a la última línea y terminará su ejecución. De lo contrario, se muestra un mensaje de error y se retorna el estado de salida del programa.

En general, esta versión alterada del código realiza una copia de respaldo del archivo "/etc/passwd", recibe una nueva contraseña para el usuario "root" y realiza algunas operaciones relacionadas con la modificación de contraseñas en sistemas Unix.
